## 行为模式总结

封装变化

•一个Strategy对象封装一个算法。
•一个State对象封装一个与状态相关的行为。
•一个Mediator对象封装对象间的协议。
•一个Iterator对象封装访问和遍历一个聚集对象中的各个构件的方法。

这些模式描述了程序中很可能会改变的方面。大多数模式有两种对象：封装该方面特征的新对象，和使用这些新的对象的已有对象。如果不使用这些模式的话，通常这些新对象的功能就会变成这些已有对象的难以分割的一部分。

visitor模式封装对一些对象结构的类的操作组，这一组操作，即相关联，又有不同。如果不用visitor模式，则visitor的代码，将分布在对应的对象结构类[element]中，但visitor从来都不是它所访问的对象的一部分。

状态模式和策略模式的UML类图几乎一样，其区别在于策略模式针封装一个算法[行为]，而状态模式则封装此状态下的一组操作。策略模式通过静态的组合，选择算法；状态模式根据状态的改变动态的选择State对象。

#### 集中还是分布

Mediator和Observer是相互竞争的模式。它们之间的差别是，Observer通过引入Observer和Subject对象来分布通信，而Mediator对象则封装了其他对象间的通信。采用哪种模式，取决于要解决什么问题以及具体的分析结果。

对于Strategy模式，其本质使将算法分布。

visitor和State模式相对复杂些，其将一些操作与被操作的数据分离[某种意义上来讲，违背了封装]，但又以另一个维度，将一些操作集中。

#### 调用解耦

当合作的对象直接互相引用时，它们变得互相依赖，这可能会对一个系统的分层和重用性产生负面影响。命令、观察者、中介者，和职责链等模式都涉及如何对发送者和接收者解耦，但它们又各有不同的权衡考虑。

命令模式将发送者和接收者之间的连接定义为一个单独的对象[Command]使得该发送者可以与不同的接收者一起工作,实现发送者与接收者解耦，使发送者更易于复用，接收者更易于扩展。命令模式通常适用于1对1的情况，即1个请求，对应一个接收者响应执行。

观察者模式通过定义一个接口来通知目标中发生的改变，从而将发送者（目标）与接收者（观察者）解耦。Observer定义了一个比Command更松的发送者－接收者绑定，因为一个目标可能有多个观察者，并且其数目可以在运行时变化。

命令模式*一般处理核心逻辑*，必须有相应的接收者处理请求；而观察者模式处理附加逻辑，可能出现没有观察者的情况。【不严谨】

责任链模式通过沿一个潜在接收者链传递请求而将发送者与接收者解耦。

责任链与命令模式、观察者模式的区别在于由责任链上的节点自身决定是否响应请求，而命令模式和观察者模式则在接收者之外的Context决定哪个[些]接受者响应。

中介者模式通过将对象间的交互【调用】逻辑封装到中介者内部，从而实现各个对象仅与中介者耦合，对象之间解耦。

结构型模式涉及到如何组合类和对象，以解决一些特定的问题，行为模式涉及到算法和对象间职责的分配以及它们之间的通信模式。

