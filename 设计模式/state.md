## 状态模式

允许一个对象在其内部状态改变时改变它的行为。对象看起来似乎修改了它的类。

 状态模式主要解决的是当控制一个对象状态的条件表达式过于复杂时的情况。把状态的判断逻辑和状态相关的行为转移到表示不同状态的一系列类中，可以把复杂的判断逻辑简化。 

### 状态模式:

**类图**

<img src="./images/state.gif" alt="状态模式类图"  />

状态模式包含以下主要角色。

1. 环境（Context）角色：也称为上下文，它定义了客户感兴趣的接口，维护一个当前状态，并将与状态相关的操作委托给当前状态对象来处理。
2. 抽象状态（State）角色：定义一个接口，用以封装环境对象中的特定状态所对应的行为。
3. 具体状态（Concrete  State）角色：实现抽象状态所对应的行为。



### 优点

1.  状态模式将与特定状态相关的行为局部化到一个状态中，并且将不同状态的行为分割开来，满足“单一职责原则”。
2.  减少对象间的相互依赖。将不同的状态引入独立的对象中会使得状态转换变得更加明确，且减少对象间的相互依赖。
3.  有利于程序的扩展。通过定义新的子类很容易地增加新的状态和转换。



### 缺点

  1. 状态模式的使用必然会增加系统的类与对象的个数。

  2. 状态模式的结构与实现都较为复杂，如果使用不当会导致程序结构和代码的混乱。
  3.  状态模式对"开闭原则"的支持并不太好，对于可以切换状态的状态模式，增加新的状态类需要修改那些负责状态转换的源代码，否则无法切换到新增状态，而且修改某个状态类的行为也需修改对应类的源代码。 

### 状态模式分析

状态模式实现效果分析：

1. **它将与特定状态相关的行为局部化，并且将不同状态的行为分割开来**

   State模式将所有与一个特定的状态相关的行为都放入一个对象中。因为所有与状态相关的代码都存在于某一个State子类中,所以通过定义新的子类可以很容易的增加新的状态和转换。

   另一个方法是使用数据值定义内部状态并且让Context操作来显式地检查这些数据。但这样将会使整个Context的实现中遍布看起来很相似的条件语句或case语句。增加一个新的状态可能需要改变若干个操作,这就使得维护变得复杂了。

   State模式避免了这个问题,但可能会引入另一个问题,因为该模式将不同状态的行为分布在多个State子类中。这就增加了子类的数目，相对于单个类的实现来说不够紧凑。但是如果有许多状态时这样的分布实际上更好一些,否则需要使用巨大的条件语句。

   正如很长的过程一样，巨大的条件语句是不受欢迎的。它们形成一大整块并且使得代码不够清晰，这又使得它们难以修改和扩展。State模式提供了一个更好的方法来组织与特定状态相关的代码。决定状态转移的逻辑不在单块的if或switch语句中,而是分布在State子类之间。将每一个状态转换和动作封装到一个类中，就把着眼点从执行状态提高到整个对象的状态。这将使代码结构化并使其意图更加清晰。

2. **它使得状态转换显式化**

   当一个对象仅以内部数据值来定义当前状态时,其状态仅表现为对一些变量的赋值，这不够明确。为不同的状态引入独立的对象使得转换变得更加明确。而且, State对象可保证Context不会发生内部状态不一致的情况，因为从Context的角度看，状态转换是原子的—只需重新绑定一个变量(即Context的State对象变量)，而无需为多个变量赋值。

3. **State对象可被共享**

   如果State对象没有实例变量—即它们表示的状态完全以它们的类型来编码—那么各Context对象可以共享一个State对象。当状态以这种方式被共享时,它们必然是没有内部状态,只有行为的轻量级对象(参见Flyweight)。

实现State模式的考虑:

1. **谁定义状态转换**

   State模式不指定哪一个参与者定义状态转换准则。如果该准则是固定的,那么它们可在Context中完全实现。然而若让State子类自身指定它们的后继状态以及何时进行转换,通常更灵活更合适。这需要Context增加一个接口,让State对象显式地设定Context的当前状态。
   用这种方法分散转换逻辑可以很容易地定义新的State子类来修改和扩展该逻辑。这样做的一个缺点是，一个State子类至少拥有一个其他子类的信息,这就再各子类之间产生了实现依赖。

2. **基于表的另一种方法**

   使用表将输入映射到状态转换。对每一个状态,一张表将每一个可能的输入映射到一个后继状态。实际上,这种方法将条件代码映射为一个查找表。
   表的主要好处是它们的规则性:你可以通过更改数据而不是更改程序代码来改变状态转换的准则。然而它也有一些缺点:
   •对表的查找通常不如函数调用效率高。
   •用统一的、表格的形式表示转换逻辑使得转换准则变得不够明确而难以理解。
   •通常难以加入伴随状态转换的一些动作。表驱动的方法描述了状态和它们之间的转换,
   但必须扩充这个机制以便在每一个转换上能够进行任意的计算。
   表驱动的状态机和State模式的主要区别可以被总结如下: State模式对与状态相关的行为进行建模,而表驱动的方法着重于定义状态转换。

3. **创建和销毁S t a t e对象**

   一个常见的值得考虑的实现上的权衡是,究竟是

   a). 仅当需要State对象时才创建它们并随后销毁它们;还是

   b).提前创建它们并且始终不销毁它们
   当将要进入的状态在运行时是不可知的,并且上下文不经常改变状态时,第一种选择较为可取。这种方法避免创建不会被用到的对象,如果State对象存储大量的信息时这一点很重要。

   当状态改变很频繁时,第二种方法较好。在这种情况下最好避免销毁状态,因为可能很快再次需要用到它们。此时可以预先一次付清创建各个状态对象的开销,并且在运行过程中根本不存在销毁状态对象的开销。但是这种方法可能不太方便,因为Context必须保存对所有可能会进入的那些状态的引用。

### 使用场景

1.  一个对象的行为取决于它的状态，并且它必须在运行时刻根据状态改变它的行为。
2.  一个操作中含有庞大的多分支结构，并且这些分支决定于对象的状态。

### 代码

略



### 其他

状态模式的类图和策略模式类似，并且都是能够动态改变对象的行为。但是状态模式是通过状态转移来改变 Context 所组合的 State 对象，而策略模式是通过 Context 本身的决策来改变组合的 Strategy 对象。所谓的状态转移，是指 Context 在运行过程中由于一些条件发生改变而使得 State 对象发生改变，注意必须要是在运行过程中。

状态模式主要是用来解决状态转移的问题，当状态发生转移了，那么 Context 对象就会改变它的行为；而策略模式主要是用来封装一组可以互相替代的算法族，并且可以根据需要动态地去替换 Context 使用的算法。