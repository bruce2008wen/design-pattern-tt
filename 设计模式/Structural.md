## 结构型模式总结

结构型模式一共包含7设计模式，其中有比较多的容易混淆的内容。

### 外观模式和适配器模式

外观模式和适配器,都是将一组API，转化为另一组API。与适配器模式比较，外观模式主要目的是整合子系统的接口集，使调用方与子系统的接口更简洁，并通过外观类实现解耦；而适配器类，为的是实现接口函数的转换，其目的是为了整合原本不兼容的若干个子系统。适配器类也可以通过适配接口，将若干个接口调用，整合到一个新接口中，在这种情况下，适配器类的行为类似外观模式。二者在实现层面没有明显的界限，但在设计层面，则明显不同，要解决的问题本质上是不同的。

适配器模式为了实现不兼容API的整合，外观模式为了简化本系统对外提供的API。

适配器使两个已有的接口协同工作，而不是定义一个全新的接口。

外观模式，在设计之初，就应该考虑；适配器模式，更多的是在实际整合不同的子系统不兼容的接口的时候采用，即遇到实际问题时的解决方案，但也不是绝对的。例如JDBC的接口，在设计之初，就是为了适配不同的数据库接口而设计出的适配器接口。

外观模式是单向的，适配器模式可能是双向的。

外观模式，实现具体业务逻辑的一定是子系统，而外观类仅进行必要的整合；而适配器模式，可能通过适配器类，可以由第三方实现具体的业务逻辑，进而实现不同接口的整合。外观模式不会提供很好的扩展能力，不符合开闭原则，但适配器模式则可能，符合开闭原则。

在设计外观模式的API的时候，只需要考虑系统内部的API整合，而不需要考虑调用方；而适配器模式，则同时需要考虑功能提供方API和调用方所需的API。

### 代理模式的分析

#### **代理模式与装饰器模式：**

代理模式与装饰器模式比较类似，都是持有了同类或父类的引用（**委托机制**），并且在函数之中调用了同类的方法来加工与同类同名的本类的相应方法，但是也有区别，**代理模式是为了减轻被代理人的工作，在不得已的时候再去打扰被代理人，而装饰器模式是为了产生新的扩展，装饰原有的属性。**

装饰器模式关注于在一个对象上动态的添加功能，然而代理模式关注于控制对对象的访问。换句话说，用代理模式，代理类（proxy class）可以对它的客户隐藏一个对象的具体信息。因此，当使用代理模式的时候，我们常常在一个代理类中创建一个对象的实例；而当我们使用装饰器模 式的时候，我们通常的做法是将原始对象作为一个参数传给装饰者的构造器。

使用代理模式，代理和真实对象之间的的关系通常在编译时就已经确定了，而装饰者必须在运行时动态的将真实对象作为参数传入。

本质上二者需要解决的问题是不同的。代理模式关注于控制对对象的访问，而装饰器模式关注于在一系列对象上动态的添加功能。代理模式对调用方隐藏真实对象的具体信息，甚至调用方都不知道真实对象的存在；由于装饰器模式实现更加灵活的动态扩展，调用方需要创建真实对象，并传给装饰器。

#### **代理模式与适配器模式：**

如果adapter类可以完美的替代adaptee【具有同样的接口，不多也不少】，此时运用设计模式的目的就不是api的转换，在这种情况下，也不需要adapter进行API转换，因此应该归类于代理模式或者装饰器模式。

### 装饰器模式和桥接模式

装饰器模式，是一系列的类的扩展，其扩展出的内容，不具备体系；而桥接模式是两【多】个自成体系的维度的结合。装饰器需保持原有体系的接口不变，而桥接模式则可能突破这一限制。

装饰器模式的目的是在接口不变的前提下，扩展功能，动态的实现继承。

桥接模式将抽象层划分为不同的维度，从而使各个维度的抽象和实现层更加独立的完成变化的过程 . 使系统更加清晰 .

将两个角色之间的继承关系改为聚合关系，就是将它们之间的强关联改换成为弱关联。因此，桥梁模式中的所谓解耦，就是指在一个软件系统的抽象化和实现化之间使用组合/聚合关系而不是继承关系，从而使两者可以相对独立地变化。这就是桥梁模式的用意。【与装饰器模式相似，但二者实现的目的不同，装饰器通过组合替代继承，扩展一系列符合Component接口的实现类的功能，其业务逻辑的主体还是Component，Decorator可以看作是Component的扩展；而桥接模式是为了整合两个或多个Component系列，多个Component系列之间可以看作是对等的关系，尽管在实现中，一定有主次之分】https://www.cnblogs.com/shun-gege/p/7514289.html



模式Bridge的结构与对象适配器类似，但是Bridge模式的出发点不同：Bridge目的是将接口部分和实现部分分离，从而对它们可以较为容易也相对独立的加以改变。而Adapter则意味着改变一个已有对象的接口。

Decorator模式增强了其他对象的功能而同时又不改变它的接口。因此decorator对应用程序的透明性比适配器要好。结果是decorator支持递归组合，而纯粹使用适配器是不可能实现这一点的。

模式Proxy在不改变它的接口的条件下，为另一个对象定义了一个代理。